git status - проверяет рабочую директорию и статус черновой области
git log - показывает все коммиты текущей ветки (ветки на которой установлен указатель)

Изменить сообщение коммита можно с помощью команды git commit --amend , она откроет редактор, в котором можно будет внести необходимые поправки в последнее сообщение.
выйти из git log - Q + enter

"git ls-files" - посмотреть какие файлы являются частью черновой зоны
"git rm" имя файла - удаляет файл из рабочей директории/индекса если он удален (также можно через: git add(зафиксирует факт удаления в черновой области) -> git commit)

Отмена промежуточных изменений, изменений внесенных в рабочий каталог(изменений не добавленных в черновую область):
"git checkout [--] (указатель последнего коммита)" - удаляет изменения вне черновой зоны, гит не переходит в другую ветку, а просто возвращает в head. Можно и без "--". Далее обращаемся к указателю последнего коммита, а именно состоянию файла "initial-commit.txt".
"git checkout ." - вернуть все файлы в состояние текущего коммита.
checkout - это традиционный способ откатить не отслеживаемые изменения в отслеживаемых файлах.
"git restore (имя файла) или (.) для всех файлов" - откатывает не отслеживаемые изменения в отслеживаемых файлах, делает это более явно чем checkout.


"git clean -dn" - удаляет не отслеживаемый файл. -d - удалить все не отслеживаемые папки и файлы; n - выводит список всего, что было удалено, но не удаляет. Потом вместо n можно поставить флаг f и удалить все принудительно.

"git reset (имя файла)" - удалить изменения, которые были добавлены в staging area если потом сделать git checkout (имя файла).q
"git restore --staged (имя файла)" - восстанавливает состояние проекта. Восстанавливает версию до появления подготовленных изменений. Тоже самое что и git reset, но более явная команда. Выполняется также с git checkout (имя файла).
git reset:
git reset --soft HEAD~1
При использовании --soft указатель ветки перемещается на указанный коммит, но изменения в рабочем каталоге и индексе остаются нетронутыми.
Это полезно, если вы хотите отменить коммиты, но сохранить все изменения, которые были в них, чтобы затем закоммитить их заново.
git reset HEAD~1 - удаляется коммит, указатель откатывается на один шаг назад и изменения также удаляются из черновой области. При этом изменения все еще есть в рабочей директории.
git reset --hard HEAD~1 - удаляет коммит, удаляет изменения из рабочей директории и из черновой области.

Удаление веток.
git branch -d(позволяет удалить ветку если ее уже слили) -D(принудительное удаление вне зависимости от того была она слита или нет)
Можно удалить несколько веток через пробел.



.gitignore
*.log(все файлы с окончанием ".log")
!test.log(убираем из списка игнора файл test.log)
web-app/*(для папок)


git stash - сохранение незакоммиченных, неподготовленных изменений.
git stash apply (индекс)- получение доступа к изменениям (последний вариант если без индекса)
git stash list - список записей
git stash push -m "Text" - создает новый именованный стеш
git stash pop (индекс, например, 0) - добавляем спрятанные изменения в проект и удаляем запись из списка
git stash drop (index) - удаление 1 записи
git stash clear - удаление всех записей


git reflog - позволяет вернуть утерянную информацию, которая относится либо к коммитам, либо к веткам(храниться 14 дней).
Для восстановления ветки нужно сначала переключиться на нужный коммит с помощью git checkout id-коммита. Попадаем в режим смещенного указателя. Далее делаем новую ветку, которая будет содержать данный коммит.
git checkout -b или
git switch -c (название ветки) - создаем новую ветку и переходим в нее



Типы слияний:

Fast-Forward - быстрое слияние с перемоткой вперед
Используется если нет дополнительных коммитов в мастер ветке(после создания feature ветки)
Merge передвигает указатель вперед, но не создает новый коммит. Избегаем создания коммита слияния.
git merge --squash (название ветки из которой сливаем изменения) - опцией squash мы объединяем все изменения сделанные в ветке, которую сливаем, в один коммит. Далее нам нужно создать отдельный коммит, который будет содержать слияние, поскольку изменения уже будут добавлены в черновую область опцией --squash

Recursive - рекурсивное слияние
git merge --no-ff (название ветки) - слияние без режима fast forward(слияние было сделано с использованием одного из вариантов рекурсивной стратегии слияния). Создается новый коммит. Используется когда есть дополнительные коммиты в мастер и фича ветках(после создания фича ветки). Дополнительный коммит слияния в мастер ветке.

Rebase
Сначала коммит в мастер становится новым родительским коммитом для коммитов фича ветки. Изменить базирование коммитов фича, на коммиты мастер. Смержить перебазированную фича с мастер. Ребейс не перемещает коммиты, он создает новые. Нельзя изменять базирование коммитов за пределами репозитория.
git rebase (название ветки откуда сливаем коммиты). Идентификаторы сливаемых коммитов меняются. Далее можно перейти в мастер и путем git merge feature слить все в мастер. Это слияние будет с методом fast forward.

Когда применять ребейс:
1. Во время работы на фича ветке появились новые коммиты в мастер ветке(основной признак). Если доработки в фича опираются на дополнительные коммиты в мастере. Т.е. в контексте текущей разработки коммиты в мастере важны для фича. Путем ребейс сменяется базирование фича на новые коммиты из мастера. Это не повлияет на состояние мастера, но изменит идентификаторы новых коммитов в фиче.
2. Когда фича завершена и ее реализация должна быть добавлена в мастер ветку без создания коммита слияния. Тогда изменяем базирование коммитов фича на новые коммиты мастера, с внесением изменения с фича в мастер в режиме фаст-форвард. Для публичных репозиториев этот момент нужно учитывать, применение ребейз переписывает историю кода.


git merge --abort - отменяет слияние
git log --merge - показывает какие коммиты сливаются
git diff - вычисляет разницу между двумя git деревьями (разница между рабочей копией и индексом). Разница между индексом и последним коммитом (git diff --staged). Разница между двумя коммитами (git diff master branchB). 

Cherry-pick - добавляет конкретный коммит в ветку (указатель). Копируем коммит с новым ID.


Теги
2 вида:
Легковесные теги - указатель на расположение коммита в ветке
Аннотированные теги - полноценные гит объекты, которые содержат информацию(например email разработчика добавившего тег)
git tag - выводит список всех имеющихся тегов
git show - показывает содержимое объекта гит.
git show 1.0(номер тега)
git tag -d (номер тега) - удаляет тег
git tag -a (номер тега) -m "some text" - создает аннотируемый тег


git remote add origin URL - origin - имя удаленной машины или алиас ссылки на удаленный репозиторий, remote - соединение с удаленным репозиторием, которое устанавливается из локального репо.
git push - переносит наши локальные данные в облако на гитлаб.
git pull - 